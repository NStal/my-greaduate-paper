[1] http://brow.data.cnzz.com/
[2] http://forums.macrumors.com/showthread.php?t=1305249
[3] http://www.cnr.cn/game/kuaixun/201304/t20130423_512427550.html
[4]http://www.alloyteam.com/2012/06/javascriptc-speed/
# Title: An HTML5 WebBased Base 3D rendering Game,一款基于HTML5 WebGL的3D游戏.
[6] http://www.ibm.com/developerworks/cn/web/wa-coffee1/
[7] https://github.com/einaros/ws
[8] http://en.wikipedia.org/wiki/Field_of_view
[9] threeJs 3D Converter
[10] http://blog.csdn.net/pizi0475/article/details/5659618
[11] http://zh.wikipedia.org/wiki/%E7%9D%80%E8%89%B2%E5%99%A8
[12] http://en.wikipedia.org/wiki/Gimbal_lock
[13] https://github.com/substack/node-browserify
# 摘要
  在很长一段时间里,用户对游戏的需求都是非常稳定而庞大的.但是用户的平台却在不断的更新.平台的更新不仅仅包括了版本的更新,还包括了新的平台的出现.随着新的平台的出现和平台的版本升级,即使是游戏这种类型的工程,虽然大部分的资源可以复用,但是代码总需要花大量的时去重新的编写,测试并优化.这种重复工作开销非常大,但是没有任何意义,甚至会引入额外的错误,导致工程的延误.
  为了避免这种重复的体力劳动,提高编程人员的生产力,项目上可以选择的方案有两种.一种是使用基于JVM一类的虚拟机,另一种是基于浏览器或者flash一类安装广泛的解释环境.针对游戏制作而言,前者在开发的便利性和普及率上有明显的缺点.尤其是普及率上的缺点,导致大部分用户需要进行额外的下载,增加了用户成本,导致了部分用户的流逝.因此跨平台的游戏往往使用的是虚拟的解释环境即浏览器或flash.
  在互联网的发展的过程中,flash提供了很好的可视化开发支持,但因为flash的闭源性质和性能低下的病垢,一直遭到了人们的质疑.尤其是下当前日益流行的OSX平台下,其CPU开销极大,以至于在iOS平台上,flash被禁止使用了.反观基于浏览器的javascript和html5平台,在开源和许多浏览器厂商的竞争之下,性能有了大幅的提升.在保证效率的同时,覆盖了几乎所有的移动终端和桌面平台.这意味着,在未来的若干年的时间里,基于javascript和html5平台的开发将会有非常好的前景,其发展也将呈现井喷式.也就是说使用html5技术开发游戏是接下来业界的发展趋势.
  过去的一两年里,许多个人和公司尝试了对HTML5游戏的设计和开发.著名的浏览器厂商开发了基于WebSocket的2D多人联机RPG游戏browserquest.又比如有人利用WebGL开发了3D的单机联机游戏.3D游戏是未来游戏的发展趋势,另一方面,多人联机游戏才能满足玩家的竞技和社交需求,也才能够为企业营造高额的利润.然后并没有前人在HTML5环境下构建过实际可运行的3D多人联机游戏.
  基于上面的分析,本文阐述了一个基于HTML5设计的3D多人联机游戏.从工程上设计了资源载入,网络通信,物理模拟,场景渲染的模块,最终实现了让玩家在不同的浏览器上享受和朋友联机游戏的过程.主要解决了一些网络通信延迟,物理模拟同步校验,以及利用WebGL库对游戏进行渲染的常见问题,最后总结了一些常见问题的应对反感.希望给后面的研究者一下参考意义.

			Abstraction
  In a long period, users' desire for game is huge and stable, but platform upgrade and changes and event come out with the new one. With the change of platform, even for project like Games, though most of the resource can be reused, still need us to spend a lot of resources to recoding ,test and optimize. This kind of work is a huge waste, meaningless and even introduce more bugs, and finally result in delay for the project.
  To avoid this kind of unwanted situation, rise the productivity of coders, the choice of project founder are limited to 2. First one is using Virtual Machines like JVM, second is use highly covered intepreter environment like browser or flash player. For game developing, the former one is so unfriendly and lake of covery. Users will have to do extra download and this defect will result in the lost of users. Thus the better choice is the intepreter environment that we can infer.
  With the growth of Internet, Flash has provide a very good visual designs for game devs. But because of it's close source and low performance, its future is questioned by a lot of people. espacially in the current in fasion system OSX, it raise an extrodinary high CPU usage rate, that force Apple to forbidden it on iOS. On the other hand, the browser based javascript and HTML5 platform are stablely grown in the fight between the browser vender, with better and better performance. meanwhile, the coverage of html5 is also high. This means that during the near future, the javascript and html5 based platform will have a good market, and the growth will also be speed up. Thus the trend of game dev is using html5 techs.
  During the past few years, many company and individuals have try to develop game in html5. such as the famous browser vendor Mozzila's 2D multi-player RPG "browserquest". And there are also good travial in 3D games of single machine, 3D is the future of game. But there is actually nobody try to build an runable 3D multiplayer game.
  Based on the analisis above, the paper demostrate a html5 based 3D multiplayer game.



# 绪言

本章阐述了基于HTML5的3D游戏开发的工程背景,国内外研究现状和发展方向,并明确的指出了在目前的各种平台下可能面临的问题,并且总体介绍了本课题的研究任务.

## 课题背景

HTML5是对下一代基于浏览器的Web技术的一个统称.并不是特指某一们技术.大体上包括了新一代的CSS3标准和许多新增的Javascript API,比如WebGL API,Audio API, Video API.

HTML5标准以及过往的大部分Web开源标准都是由W3C(http://www.w3.org/)组织起草维护和推动的.W3C组织的成员主要是各大浏览器和操作系统的厂商和互联网服务提供商,比如Google Chrome,Mozzila Firefox,MicroSoft IE.其中也包括中国的一些厂商比如UC浏览器,腾讯百度等.大部分的标准都是由核心的W3C成员起草和商议,然后由W3C的众成员实现的.但是起草的过程由于是讨论的过程,因此多多少少有一些反复,出入.个浏览器厂商的实现也有先后和版本之分.但是HTML5依然是目前覆盖最广泛开发最方便的平台.目前所有的智能移动设备都支持或支持一部分HTML5功能,并且在可以预测的未来,这种普及率将会快速的得到扩大.根据数据数据显示[1]支持html5标准的桌面浏览器超过了50%(本文撰写时为50.65%,并且还在快速的增长),而对应的移动设备则几乎是100%.这意味着如果有合理的工程设计和开发流程,一次代码的编写能够在众多设备无需额外工作的完美运行,这将节省非常多的成本.

2012年智能手机的移动市场份额首次超过了其他所有游戏的市场份额达到了51.16%[3],综合HTML5平台在移动平台的普及率,更加标志着HTML5平台在游戏领域的发展还有很多的扩展的余地.

除开成本因素,HTML5带来的用户体验上的提升也是非常值得我们研究和考虑的.使用Flash技术实现的应用和游戏往往有CPU使用率过高导致卡顿甚至影响用户进行别的操作的问题,然而由于HTML5是开源技术并且由世界顶尖的IT厂商比如Google,苹果,MicroSoft共同维护,因此效率和可靠性要高的多.

另一方面随着HTML5的推出,更多的API被暴露给了中层开发人员.曾经在Web上使用GPU加速是不可能的,但是随着WebGL标准的推出,开发人员可以利用在Web上编写GPU加速的Shader.Shader可以直接经过WebGL标准并行的运行在GPU上,最后通过Canvas暴露运行结果.通过这种方式Web就可以实现曾经经几乎不能实现的复杂3D效果.HTML5标准还伴随了一个新的通信协议WebSocket.曾经的开发人员在Web上的通信主要是基于HTTP(Hyper Text Transformation Protocol).然后HTTP协议是一款无链接的协议,因此每次通讯的开销和延迟都非常的大.WebSocket更加类似于底层的Socket TCP协议,只不过在TCP协议的头部增加了一个短小的头,并且对二进制和文本分段有较好的封装.有了这样的一个更加底层的API,Web开发人员能够开发出延时更小开销也更小的应用.而在其中游戏则可以将这些优势全部利用起来.

除了丰富的新的API,Javascript在一些浏览器厂商的推动下,其效率和开发简易程度已经得到了大大的提高.在极限的运算下Chrome V8引擎下Js的效率已经达到了原声C语言的1/16[4]远远的甩开了其他服务器语言比如python和ruby.

## 课题目的和意义
   虽然HTML5和基于Web的3D技术的推出已经有了一定的时间,但是HTML5游戏并没有对3D和多人联机游戏以及物理即使模拟的混合尝试.由于缺乏这方面的尝试,厂商们贸然的跟进这项新的技术就需要承担着技术风险,甚至是经济风险,于是导致了游戏开发厂商不愿意简单的跟进这项非常有前途的技术.由于大型厂商不跟进,开发从业人员也因为没有好的先例进行参考所以无法着手开发,而选择老的成熟保守,而又面临过时的技术.
   为了解决基于基于HTML5 Web3D这门前沿技术的尴尬,本课题希望通过设计并实现一套完整的3D模型联机式的物理模拟方案,来为业界后续的发展做一些前瞻性的尝试.从而在某种程度上打消游戏厂商的顾虑,并给其他的Web开发者一些参考样例.

## 国内外研究概况
   在HTML5标准推出的过去一两年中,许多开发人员对HTML5的能力做了尝试.其中比较突出的有两款.一款是浏览器厂商巨头Mozilla推出的Browser Quest.另一款是有bkcore黑客开发的Hexgl.
   Browser Quest,是用HTML5 2DCanvas和websocket技术融合所开发的一款多人RPG游戏,位于不同物理位置的玩家通过打开一个网页,而共同进行一个RPG(Role Play Game角色扮演游戏).这在传统的Web开发中是无法想象的,首先传统的Web开发中没有2DCanvas,因此绘图非常的慢,而且不具备通用绘图功能,只用用图片取代.在网络方面传统的游戏开发过程中使用HTTP长链接来维持和服务器的链接,HTTP长链接是通过和服务器开启一次HTTP链接而不关闭,从而实现时时通讯的功能.HTTP长链接开销是非常大的,而且根据实际的包路由的状况也不是非常的稳定,因此会导致非常糟糕的游戏体验甚至会在中途中毒游戏.由于在Browser Quest 中创新的使用了HTML的WebSocket技术,这项技术才用了类似TCP Socket 的WebSocket 技术,解决了传统的Web开发中和服务器联机的实时性问题.不过美中不足的是Browser Quest的这次尝试并没有很好的解决了网络延迟带来的实际体验的下降和不同步的问题.而且使用的也是简单的2D方式,不符合未来游戏的发展趋势.
   Hexgl,则是使用 基于HTML 3D API-WebGL 的Threejs库进行开发的一款3D单机赛车游戏.游戏的方式是玩家通过登陆网页的方式进入游戏,然后针对特定的地图场景,进行定时的竞速.如果玩家在规定时间不经过太多的碰撞达到终点则为胜利.完结可以在3D的场景中进行比赛,这样更有代入感.这款3D游戏也是有非常创新的意义,因为它使用了GPU加速的功能.2DCanvas对于大量的3D点阵和纹理映射必须串行的利用CPU进行计算,在没有优化的CPU运算下,如此复杂运算每毫秒的应用场景下这是不可能的.如果没有GPU加速的功能利用2DCanvas,只能实现非常基本3D渲染,并且CPU的使用率会非常的高,想过也会非常的不理想.但是通过开发使用GPU加速功能,游戏的特效渲染达到了一个新的档次.可以和Native的小成本游戏制作相提并论.但缺点是作为一款视觉效果非常好的赛车游戏,却不允许用户联机竞赛游戏,导致游戏的体验大打折扣.

## 课题的主要研究工作
站在前文提到的两款游戏的基础上,本文希望改良他们的缺点,并柔和他们的优点,制作一款拥有3D场景的多人联机游戏,并应用一些复杂的物理运算来证明HTML5技术和前端技术在生产环境下的可操作性.

本课题需要解决的问题主要是,在Web环境下的3D物理模拟和渲染,以及多台客户机器之间物理信息的同步和校验.本课题将着重探讨使用WebSocket构架小延迟物理同步的系统设计远离和物理引擎的模拟.作为附属,3D游戏开发的一些必备模块和工具的选用和开发也在本文的讨论范围之内.

通过实际设计开发和总结一套3D联机游戏开发流程从而最终达到一次前瞻性的探索,为业界的开发人员留下一些可以参考的思路和数据.

# 游戏框架的构架设计
## 总体设计构架概览.
  首先这个项目被命名为X-Nolava,Nolava是Avalon的反写,意味着虚幻世界.其总体构架如图2.1所示.总体上氛围前端渲染程序和后台同步程序两大模块,前端程序主要负责游戏界面的渲染以及和用户的交互,即相应用户的操作,并向用户展示游戏的状态,等待用户的反馈.而后台部分则主要针对用户的登陆进行校验,当有若干个用户同时进行游戏的时候会对他们进行数据同步和物理校验.针对每一个用户更新的操作,后台会将这些操作处理认证之后统一广播给所有的客户端.

### 前台系统的模块划分
[image#3]  
前台的框架设计如图三所示.主要分为,资源加载模块,物理模拟模块,3D渲染模块,和网络通信协议模块,和主控制模块.

资源加载模块实现的功能是游戏素材的加载和组装.3D游戏是一个非常复杂的工程,仅仅是一个简单的带贴图的立方体可能就涉及数个个资源.贴图的管理则更加的麻烦.而且前端素材的加载需要相当数量的时间,如果这些加载的操作在主程序逻辑中实现的话会变的非常的复杂.于是为了实现的方便,把资源载入模块单独独立出来,并在主逻辑之前运行.物理模拟模块的功能是根据游戏的规则模拟宇宙中的物理效果.比如根据飞船的动量旋转适量和玩家的操作模拟出接下来的船的位置3D渲染模块的功能是把物理模拟出的场景给绘制出来并反映给用户.网络通信模块的功能是建立起与后台的链接,当链接开始或中断时通知其他相关的模块.最后是主控模块.主控模块的功能是组织其他的模块,负责模块之间的沟通,并且相应用户交互的逻辑.比如用户按下前进按钮,主控模块通知物理模块改变船的状态,并通过网络通信协议模块告知后台发生了变化.值得一提的是游戏的主时间循环也是由主控模块管理的.

### 后台系统的模块划分
[image#4]
后台的框架设计如图4所示.除了没有3D渲染和资源加载部分以外其他的和前台非常类似主要分为,网络通信协议模块,客户端管理模块,物理模拟模块,和主控模块.

网络通信模块负责处理和和前台的链接开通和中断,并且在链接状态发生变化的时候通知主控模块.客户端管理模块负责维护和客户端的链接状态并且记录会话信息(Session).物理模拟模块和前台的物理模拟模块一样,实际上代码也是公用的,这在后面会详细介绍.主控模块负责组织其他的模块,并且监视所有客户端的动态,当有客户端发出相关指令的时候,广播给其他的客户端也是主要控制模块的责任.

## 前端相关API以及工具的调研开发和实现
前端主要使用了HTML5 的 WebGL API 和Websocket通讯API.其中WebGL API是非常底层的GPU调用,并不是非常适合直接的构架3D游戏,因此引用了了上层的一个著名的封装threeJs,目前互联网上的大部分HTML5 3D游戏也引用了这个库.



### Websocket 
WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协定于2011年被IETF定为标准 RFC 6455，WebSocketAPI被W3C定为标准。
在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。

现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源。而比较新的技术去做轮询的效果是Comet，使用了AJAX。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在Comet中，普遍采用了长链接(HTTP Long Pull)，这也会大量消耗服务器带宽和资源。面对这种状况，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽并达到实时通讯。
服务器与客户端之间交换的标头信息很小，大概只有2字节。（早期版本）服务器可以主动传送数据给客户端。在实现websocket连线过程中，需要透过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” (handshaking。)后期的版本大多属于功能上的扩充，例如使用第7版的握手协议同样也适用于第8版的握手协议。
浏览器请求

```GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: null
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13```

服务器回应
``HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Origin: null
Sec-WebSocket-Location: ws://example.com/```

在请求中的“Sec-WebSocket-Key”是随机的，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个魔幻字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”。使用 SHA-1 加密，之后进行 BASE-64编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。 实现websocket的协议，浏览器扮演着一个很重要的角色。Google在它的Google Chrome支持了websocket，Chrome 5 之后的版本都支持websocket，但因为websocket还未最终版本，草案不断更新，所以不同的版本会支持不同的草案。 苹果公司的Safari浏览器也支持websocket。(iPhone4上的safari使用的WebSocket是旧版的握手协议,可以使用本页的握手协议来制做服务器端) 起初，Mozilla基金会的Mozilla Firefox会在4版本支持websocket。Opera软件公司方面在Opera 10.7和11.0的预览版本中也支持了websocket。然而，基于安全因素的考虑，两家宣布将暂时移除该功能。FireFox预计于版本6重新实现WebSockets RFC Version -07 ，但此版本实现并不向后兼容，故旧版本的服务器实现软件有可能无法顺利运行。版本6之中的WebSocket功能将会默认打开。在FireFox6的版本里，WebSocket 被更名为 MozWebSocket，但是该 class 的成员与用法皆与 WebSocket 相同。

WebSocket的Javascript API主要是创造WebSocket的实例,并监听3个事件.创造WebSocket实例需要传入的参数是遗传WebSocket协议地址.他的形式是"ws://host:port/path",非常类似HTTP协议的地址.其实"ws://"是协议名称,host/port/path 是服务器的地址,端口和路径,其中路径并不是必须的,只是为了第一步和HTTP协议做无缝转换时需要的.需要监听的三个事件分别是"open","message"和"close".分别表示WebSocket的三个状态的变化,其中最关键的是message事件,它表示服务器传来了新的数据.跟服务器发送数据则是通过send方法.websocket允许发送string和binary两种类型的数据,为了解码方便,本课题主要采用string的传输.

### WebGL 和 Threejs
WebGL的（Web图形库）是一个JavaScript API渲染交互式3D图形和2D图形在任何兼容的Web浏览器运行库，无需使用插件。 WebGL是完全集成到所有的Web标准的浏览器允许使用GPU加速的物理和图像处理效果的网页Canvas。 WebGL的元素，可混有其他HTML元素并合成 WebGL的计划包括控制在JavaScript编写的代码和着色器执行的代码,来对电脑的图形处理单元（GPU）的页面或页面背景的其他部分的控制。 WebGL是设计和维护由Khronos集团非营利。 WebGL是基于OpenGL ES 2.0的3D图形，并提供了一个API。为了安全起见，GL_ARB_robustness（的OpenGL3.x的）或GL_EXT_robustness（OpenGL ES的）是必要的。它使用HTML5 canvas元素和使用文档对象模型接口访问。自动内存管理是JavaScript语言的一部分。 WebGL缺乏OpenGL 3.0的矩阵数学方法。而此功能是通过使用JavaScript代码空间的用户来完成，这经常辅以必要的代码矩阵库，如glMatrix，TDL，或MJS来实现。通过使用WebGL,我们可以实现复杂的3D效果而不用消耗过多的CPU时间.

但是由于WebGL是基于OpenGL ES标准的API,也就是说WebGL的API非常的底层,非常的复杂,而且没有相应的数学工具.于是我们选用了一个简单基本,而且文档丰富的封装ThreeJs.Threejs 是由MRDoob 开发的一款基于Web的开源3D基础框架,主要包括了简单的数学预算比如偶拉和4元数的变换,和基本的obj模型读取工具以及场景相机等3D中最基本的元素。随着Threejs 的出现我们现在能够更快的开发出web中的3D应用了,而不用花过多的时间在构建基础框架上.
最新版本的threejs文档和安装方法可以参考 https://github.com/mrdoob/three.js/.

  ThreeJs的核心API模块包括,Camera,Core,Lights,Loaders,Material,Math,Objects,Renderers,Scene,Texture.这些模块构成了现代3D渲染理论的一些基本元素.
  一个场景首先要创建一个Scene实例,这个实例在后续用来存放3D物件和相机等场景中的组建.之后通过Lights,和Camera模块像场景中添加光和相机.相机负责把3D世界中的物件通过相机预设的位置旋转所构成的矩阵,映射到2D空间中去.然后经过GPU的裁剪就变成了我们现在肉眼可以看见的屏幕上的图像.相机的实例主要接受这样几个参数,FOV,寬高比,最近点和最远点.其中寬高比顾名思义指的是选出的结果宽度和高度的比值,最远点和最近点的意思是,如果物件不再这个范围内,那么就不会被渲染出来.FOV的全称是Field Of View,是一个比较复杂的映射概念,我们会在后面的设计中详细介绍.如果场景没有光线的话,那将是漆黑的一片,因此我们至少要通过Lights模块构建一个光源的实例.光源的实例分3种,分别是点光源,向性光源和环境光源.其中点光源和向性光源顾名思义描述的就是由单点发出的像四周散射光线和朝着单一方向的光线.而环境光源则概念上类似日照中的多次漫发射所造成的基本光线.不同的光源在GPU中的渲染方式不同.点光源是通过计算面的法向量和和点光源连线的夹角来判定面的光照强度.向性光源则是用面的法向量直接乘以光线方向的向量,环境光则最简单直接为一个常数并带入最后的混合计算即可.没一个栅格化的点最后的颜色都是有面的固有颜色诚意光源和其强度所决定的.在后面的设计中我们还会详细介绍.

  有了相机和光线场景的基本渲染的雏形就实现了,接下来就是利用Core API添加和心的三维物件,通过Material API给物件贴上纹理提供更好的效果,接下来利用Math API计算物理位置和帧变化.最后使用Renderer API将场景栅格化到3D Canvas上去.这其中具体的步骤和远离会在后面的渲染章节中介绍.

## 后台开发和优化工具的调研
  开发一款复杂的Web应用尤其是像游戏这样的工程,面临这许多问题.主要的是,开发量大,前后台一致性难以保证,同步调试困难以及性能要求高.为了解决这些问题,本课题对后台的开发工具和优化工具做了一些调研主要的选择如下.
  为了解决开发量大的问题,本课题选择了CoffeeScript这门宏语言编译成Javascript,后台选择nodejs与前台共享核心的物理模拟代码,解决一致性问题.测试和调优采用Google Chrome浏览器的Debugger.

### CoffeeScript
[6]CoffeeScript 编程语言是构建于 JavaScript 之上，它可编译成高效 JavaScript，您可以在 Web 浏览器上运行它或者将其与诸如 Node.js 一类的技术相结合用于构建服务器端应用程序。编译过程通常都很简单，生成的 JavaScript 均与许多最佳实践保持一致。JavaScript 是最重要的编程语言。这是一门浏览器语言，正越来越频繁地出现在桌面和移动应用程序中。随着 Node.js 的日益普及，JavaScript 已经成为了服务器和系统应用程序一种切实可行的选择。一些开发人员强烈抵制 JavaScript，大部分原因是因为其不一致的语法和古怪的实现。不过，随着 JavaScript 虚拟机变得越来越标准化，古怪的实现已经逐渐减少。不一致的语法则可能会随着 JavaScript 的下一次革命：ECMAScript.next 的到来而得到一定的解决。ECMAScript.next 是一个新兴标准，深受 CoffeeScript 的影响。不过，在新标准被接受并且被流行虚拟机实现之前，JavaScript 语法还需要进一步改进。
如果您正在等待 JavaScript 运行时，CoffeeScript 会是一个有吸引力的选择。从语法的角度来看，JavaScript 是不择不扣的大杂烩，它具有许多函数式编程语言的功能，特别是深受 Scheme 的影响。然而，Scheme 是构建于 S-表达式之上的一种非常简单的语法。JavaScript 沿袭了 Scheme 中的许多概念，但是却没有采用它的语法。相反，JavaScript 拥有类似 C 的语法。结果是，一种有着函数式概念的语言，但却有着冗长的语法，而没有用于表达这些概念的自然构造，例如，JavaScript 允许高阶函数，比如，那些其输入参数包含其他函数的函数。这既有用且功能强大，是许多语言都缺少的功能。而CoffeeScript的语法类似于Ruby,简洁并且非常强大.他能够编译成javascript也可以直接在后台运行(基于nodejs).并且有很好的面向对象以及枚举的支持,而这两者可以大大的增加开发的效率,这也是本课题采用CoffeeScript的原因.

### nodejs.
  在网络游戏的开发过程中服务器和前台的一致性问题一直是焦点,如果因为数据类型的不兼容或者小的误差经过长时间运行的积累,就会导致整个游戏服务不可用或不可靠.而为了保证前后台服务的一致性,开发人员往往要付出非常多的努力,测试和迭代修改.但是这并不是唯一的方法.随后nodejs等类似的javascript后端渲染的实现,通过同样的一份带共享渲染引擎来实现前后台的完全一致就大幅度的减少或者根本上的避免了这些问题.
  nodejs 是一款利用chrome的javascript engine V8 作为核心支持commonjs,Module2.0规范的一款javascript后台实现.nodejs不仅仅是一款javascript的后台实现,而且是一种IO高效的实现,而高IO也是网络游戏开发中面临的主要问题之一.nodejs的特性在于利用libuv而达到了大吞吐量异步IO的效果.关于IO阻塞问题,传统的开发采用多线程等待的方式,这样一来就有非常多的线程切换,现场保存的操作.这些操作的开销是非常大的.由于nodejs使用libuv这个利用硬件中断的IO库,然后采用完全的单线程模型,完全没有线程/进程切换的开销,大大的减少了可能出现的进程开销问题.除此之外,使用nodejs的优点还有可以在前端和后太共享代码,从而真正意义上的达到了一次开发随处部署的程序员之梦.而对于开发多人联机游戏而言,使用nodejs的话能够在前台和后台使用同样的一套物理引擎进行演算,因此能够很好的重复利用代码.换一个角度来说,由于根本用的就是同样的一套代码,所以就算出现了Bug,后台和前台的大部分核心Bug也是统一的,只要解决了一个地方其他的地方也就跟着解决了.
  我们的后台nodejs开发主要使用WebSocket模块的后台实现也就是ws模块.这个模块通过npm(Node Package Manager)程序进行加载.我们可以通过调用"npm install ws"的方式自动的完成这个模块的下载并且解决它的各种依赖问题非常方便.nodejs的WebSocket模块和前台的非常相似,唯一的区别在于数据的接受的格式不同.nodejs中数据接受的格式更加简单.可以参考吉特哈布-"WS"模块文档[7].
  nodejs和CoffeeScript也有非常好的结合.使用nodejs可以直接引用CoffeeScript构造的模块.主模块也可以用nodejs的特定封装"coffee-script"程序来运行,避免了额外的编译操作.
  
### Google Chrome Debugger
[chrome 截图 Debugger]
Chrome 是由Google 公司根据Chromium开源浏览器改造的一款高性能浏览器.其V8 Javascript内核效率非常高,Nodejs也在使用. 但Chrome不仅仅是一款非常优秀的浏览器,他的调试工具Chrome Dev Debugger,也非常的方便.其主要功能有,断点设置,单步调试,全局变量查看,查看函数栈,以及性能分析.

[Todo Extend With Windows]


# 3D多人联机游戏的具体分析和实现

## 用户层模块的实现
用户层模块主要包括3D渲染和用户交互响应.

### 3D 渲染模块.
一个三维的场景大体上来说有两个最基本的元素构成他们就是scene和camera.scene决定了整体的渲染方式,比如是否有雾气,能见度是多少.而camera则决定了最终我们如何从三维场景中投影到二维场景.主要的参数有FOV[8],far,near,其中far和near分别定义了离camera最远和最近的可视距离.FOV的全称是field of view.定义了三维场景中的景物投影到平面二维成像时的成像方式,FOV过小就会呈现出鱼眼镜头的感觉.一般设置在35-45之间会有比较好的效果.

这款游戏的摄像机有一些特殊的要求,摄像机需要主动跟随玩家所控制的飞船并且随着飞船的转动摄像机也跟随者一起转动.于是在开发的过程中,扩展了ThreeJs自带的Camera类.用ShipCamera扩展了Camera类,添加了一个额外的方法follow.通过follow方法可以设定摄像机具体跟随三维空间中的哪一个个体.当个体发生变化的时候调用ShipCamera的update方法可以及时更新摄像机的动态是他根据预设的角度看向物体.在本工程中这个预设的角度和距离是"@targetDistance = 3000"和"@towards = new Three.Vector3(-0.5,0.1,0)".其中距离的单位是真实世界中的厘米.ShipCamera默认的FOV是35.

[TODO 扩展FOV的相关信息]
[不同FOV下的效果]

游戏的背景是被设定在宇宙之中,于是我们需要一个虚拟的宇宙空间.虚拟宇宙空间的实现使用一个非常巨大的立方体,内部贴上星云的图片来实现的.这个Cube使用的是ThreeJs的Cube对象.这个对象在资源加载模块就被载入了.大小被设置成了1000000000.通过设置成这样一个在有限时间内很难达到的边界来模拟无限边界的情况是自由世界游戏常用的方法.内部的贴图使用的是EVE开源的宇宙贴图.贴图使用了ThreeJs做的一个简单的专门对于Cube的简单的封装.可以实现纹理异步加载,即使加载完全之前也不会影响游戏大体的渲染(未加载完成的贴图用单一的颜色替代).本文方才描述的技术方案被称作CubeMa,通过把立方体的大小设置成非常大的方式,我们就能够让人产生飞船怎么飞也不会飞到宇宙的边缘的错觉从而达到了模拟玩家在宇宙中飞行的目的.

[# 6]

游戏的飞船和其他物体使用的是Obj格式3D点阵信息.通过用python实现的obj2json转换器实现.这个转换器是由ThreeJs实现[9].转换出来的信息为JSON格式,主要包含下面的这些信息

[表格]
```
"metadata" :
    {
        "formatVersion" : 3.1,
        "sourceFile"    : "spaceship.obj",
        "generatedBy"   : "OBJConverter",
        "vertices"      : 8713,
        "faces"         : 6814,
        "normals"       : 8713,
        "colors"        : 0,
        "uvs"           : 8703,
        "materials"     : 2
    },

    "scale" : 1.000000,

    "materials": [	{
	"DbgColor" : 15658734,
	"DbgIndex" : 0,
	"DbgName" : "c8bec9bd.dds",
	"colorAmbient" : [0.8, 0.8, 0.8],
	"colorDiffuse" : [0.7, 0.7, 0.7],
	"colorSpecular" : [1.4, 1.4, 1.4],
	"illumination" : 0.5,
	"specularCoef" : 1,
	"transparency" : 1.0,
	"mapAmbient" : "normal.png",
	"mapDiffuse" : "normal.png"

	},

	{
	"DbgColor" : 15597568,
	"DbgIndex" : 1,
	"DbgName" : "973653b1.dds",
	"colorAmbient" : [0.4, 0.4, 0.4],
	"colorDiffuse" : [0.4, 0.4, 0.4],
	"colorSpecular" : [1.0, 1.0, 1.0],
	"illumination" : 2,
	"specularCoef" : 1.0,
	"transparency" : 0.6,
	"mapAmbient" : "diffuse.png",
	"mapDiffuse" : "diffuse.png"
	}],

    "vertices":
```
其中metadata是obj文件对应的头信息.metadata下的vertices/faces/normals/colors/uvs/materials信息就是对应的模型的点,面,法向量,颜色,uv曲面,材料信息的数量统计.后面的materials跟随的是材质信息.材质信息主要是由颜色参数,光照参数和纹理文件信息组成.当有纹理信息的时候颜色信息会被忽略.最终合成的效果是通过颜色信息与光照信息或者纹理信息与光照信息组成.值得一体的是虽然materials参数中有transparency一项,但是并不会被ThreeJs正确识别,必须在后期处理的过程中手动标记.并且放入alpha队列里去.alpha队列指的是根据物体的z轴信息,对透明度非1的物体进行排序最后依次绘制.因为半透明物体的本质就是采用alpha混合依次实现,因此透明物体的顺序会导致效果不同.如果不放入alpha队列则会导致随机的alpha混合顺序,最后经常会出现无法正确渲染或者渲染出黑色边框或者遮盖住后面物体的情况.meterials信息之后就是具体的vertices/faces/normals信息.其中vertices是3D物体所有的点的相对坐标.faces是所有的面对应的3个点的引用.而normals则是通过对面的引用然后标志出该面的正面和反面.在渲染的时候为了节省时间非透明的物体的背面是不参与渲染的.需要指出的是对于之前提到的CubeMap必须设置flipSide的值为真.这样才会在CubeMap的里面现实出我们想要的宇宙效果.

在理解了这些信息的前提下,可以直接较高ThreeJs的相关类构建出Mesh.但是需要指出的是,这些工具连还在开发和维护的早期,有非常多的问题和没有被文档指出的细节,因此在使用的时候一定要非常注意,并且要理解细节.

把载入的JSON格式的3D物件信息倒入后,为了达到更好的游戏体验和视觉效果必须对物体的渲染模式进行更加细致的制定.因为普通的3D模型直接观看的话都是非常粗糙,是没有细节和质感的.这里我们给飞船的玻璃保持原始质感,但是机身加上钢材的反射效果.刚才的反射效果是通过添加一层额外的纹理,然后把跟镜面反射的线光源的混合比设为0.8,即有非常好的效果.反射贴图的选取有两种方式,第一种是每一桢的时候都从目标的视角再次渲染一边整个场景,然后渲染的结果就作为额外的贴图根据反射比例粘贴到目标物体的表面上去。第二种就是使用现成的整个世界的cubemap world作为额外的贴图粘贴到物体上面去,在大型的场景下,两种方式做带来的视觉上的变化并不是非常的明显但是性能上的差距则是天壤之别,前者由于无法预先计算而且根据物体的数量的变化所需要进行的重复计算非常非常的多,随着物体的增加效率会下降的非常非常的严重因此我们还是选用后面的一种方式作为我们游戏中的主要反射的选方式.

飞船发射出来的子弹我们使用,宽度和高度非常小,但是深度非常长的立方体来模拟.并且一并在资源载入的时候初始化成Mesh结构.而子弹的爆炸,是使用的完全不同的实现方式.在3D空间中想创造线性柔滑的效果只能依靠平面贴图.而爆炸又是球体的,因此非常难以用贴图的方式贴出一个符合我们需求的球体.因此这里工程才用了一种不同3D个体,Sprite.Sprite描述的是这样一种3D个体.首先它是一个平面,但是这个平面始终是面朝相机的.当然这个面可以选择有大小透视,也可以选择没有大小透视.这里我们选择有大小透视的Sprite来营造爆炸的效果,后面的介绍的HUD会使用到无透视的Sprite.通过Sprite贴一个中心最亮然后到边缘缓慢渐渐消去的圆,如图[#7]所示.这个Sprite不管相机在任何角度,他都会面朝相机,这样视觉效果上仿佛就是一个圆形.



### HUD 和3D到2D的矩阵投影.
平视显示器（Head Up Display），以下简称HUD，是目前普遍运用在航空器上的飞行辅助仪器。平视的意思是指飞行员不需要低头就能够看到他需要的重要资讯。平视显示器最早出现在军用飞机上，降低飞行员需要低头查看仪表的频率，避免注意力中断以及丧失对状态意识(Situation Awareness）的掌握。因为HUD的方便性以及能够提高飞行安全，民航机也纷纷跟进安装。部分汽车业者也以类似的装置作为行销的手段吸引顾客，不过使用上并不广泛。

HUD是利用光学反射的原理，将重要的飞行相关资讯投射在一片玻璃上面。这片玻璃位于座舱前端，文字和影像被投射在镀膜镜片(析光镜)并平衡反射进飞行员的眼睛。飞行员透过HUD往前方看的时候，能够轻易的将外界的景象与HUD显示的资料融合在一起。由于反射进眼睛中的影像永远与飞机的中轴平衡，所以飞行员的身高不会对俯仰角或目视瞄准造成偏差。HUD设计的用意是让飞行员不需要低头查看仪表的显示与资料，始终保持抬头的姿态，降低低头与抬头之间忽略外界环境的快速变化以及眼睛焦距需要不断调整产生的延迟与不适。HUD投射的资料主要与飞行安全有重要关系，譬如飞行高度，飞行速度，航向，垂直速率变化，飞机倾斜角度等等。使用于战斗环境时，还会加上目标资料，武器，目视瞄准器与发射的相关资料，预估命中点等等。这些显示的资料能够根据不同状况而变换。通过在游戏中引入HUD模拟设备,我们可以大大的提高游戏的体验让游戏具有更好的可玩性,并且让玩家更有真实感.[Image 6]

HUD中目标追踪的实现需要依赖3D到2D平面的投影矩阵的计算.使用公式[10][Image # 8],所得到的世界投影矩阵去乘以目标3D物件的坐标向量就能得到目标的在显示器上的坐标.必须指出的是相乘所得到的是一个三维的向量,其中前两项是平面的横坐标和纵坐标.第三个坐标表示的是从正面还是从背面映射过来的.在HUD的实现过程中,如果发现了从正面映射过来的坐标,那么直接打一个小红点.如果是从背面映射过来的坐标,则需要计算坐标的区间.如果偏下就放到屏幕的底端,偏上就放到顶端,左右轴上也采用同样的算法.这样一来,玩家就可以通过屏幕判定屏幕之外的在何处,并且知道该如何才总飞船才能正面朝向物体的.

### GPU着色器和渲染程序
着色器（shader）应用于计算机图形学领域，指一组供计算机图形资源在执行渲染任务时使用的指令。将着色器应用于图形处理器（GPU）的可编程流水线，来实现三维应用程序。这样的图形处理器有别于传统的固定流水线处理器，为GPU编程带来更高的灵活性和适应性。[11]

着色器主要分为3种。顶点着色器处理每个顶点，将顶点的空间位置投影在屏幕上，即计算顶点的二维坐标。同时，它也负责顶点的深度缓冲（Z-Buffer）的计算。顶点着色器可以掌控顶点的位置、颜色和纹理坐标等属性，但无法生成新的顶点。顶点着色器的输出传递到流水线的下一步。如果有之后定义了几何着色器，则几何着色器会处理顶点着色器的输出数据，否则，光栅化器继续流水线任务。 几何着色器可以从多边形网格中增删顶点。它能够执行对CPU来说过于繁重的生成几何结构和增加模型细节的工作。。OpenGL只可通过它的一个插件来使用几何着色器，但极有可能在3.1版本中该功能将会归并。几何着色器的输出连接光栅化器的输入。 片断着色器，处理来自光栅化器的数据。光栅化器已经将多边形填满并通过流水线传送至像素着色器，后者逐像素计算颜色。像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片断着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片断着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。

GPU的着色渲染流水线大概是这样的一个过程:中央处理器（CPU）发送指令（编译的着色器程序）和几何数据到位于显卡内的图形处理器（GPU）。 顶点着色器执行几何变换和光照计算。 若几何着色器位于图形处理器内，它便会修改一些几何信息。 计算后的几何模型被三角化（分割为三角形）。 三角形被映射为2×2的像素块。着色器被用来同时处理大量的数据，比如屏幕上的一整块像素群，或者一个模型结构的所有顶点。并行计算适用于这样的情况，而且当今的GPU也设计有多核结构来极大的提高处理效率。

3D中所有能看到的部分全部都要经过Shader进行渲染.基本的渲染Shader,ThreeJs有了封装,但是这无法提供足够好的效果.所以尝试制作了单独的shader提供更好的效果.为了混用多个shader,并且提供方便的全局效果.项目中使用了Shader Pass和Compose Renderer来实现对buffer的多次渲染来达到特殊的效果.这里本文实现了一个高斯模糊的特效.因为直接做5阶级的高斯模糊的算法复杂度过高导致无法在事实渲染的过程中对整个画面做完整的高斯模糊.这个时候我们在图形纵向的5个单位上做一次高斯模糊,其算法作为一个ShaderPass,然后再在另一个维度上做5个单位的高斯模糊,作为另外一个ShaderPass,然后通过Compose Renderer再回合到普通的webgl 画布上去,从而最终实现了完整的高斯模糊特效.所有的Shader切换和Buffer的管道全部都在GPU的内部实现因此非常快速.

## 游戏物理引擎的实现.
游戏物理引擎的实现主要是对多维向量按照时间积分,碰撞检测.

### RK4积分算法和其实现
平时我们粗略计算变化速度在时间上的变化采用的是欧拉积分,也就是S+V*dT这个简单的公式.但是在游戏中dT是一个比较大的量一般在10ms左右,另一方面V往往是个变化量.因此需要更加精确的积分方法来避免过大的误差.RK4积分算法在精度上和运算复杂度上都有很大的优势,其精度达到了O(x^4)但有只需几次简单的迭代。这里使用类似C++的为代码对这个算法的实现进行描述.
首先定义一个物体的位置和速度.    
strcuct{
         float X; //位置
         float V; //速度
};
然后定义他的变化量.
struct Derivative
{
     float DX; //位置变化
     float DV; //加速度
};
然后进行迭代的算法如下伪代码所示
Derivative evaluate(const State &initial, float t, float dt, const Derivative &d){
         State state;
         state.x = initial.x + d.dx*dt;
         state.v = initial.v + d.dv*dt;

         Derivative output;
         output.dx = state.v;
         output.dv = acceleration(state, t+dt);
         return output;
}
对加速度进行迭代的算法
float acceleration(const State &state, float t){
         const float k = 10;
         const float b = 1;
         return -k * state.x - b*state.v;
}
最后是积分拟合的算法,从T到T+dT:
void integrate(State &state, float t, float dt){
     Derivative a = evaluate(state, t, 0.0f, Derivative());
     Derivative b = evaluate(state, t, dt*0.5f, a);
     Derivative c = evaluate(state, t, dt*0.5f, b);
     Derivative d = evaluate(state, t, dt, c);

     const float dxdt = 1.0f/6.0f * (a.dx + 2.0f*(b.dx + c.dx) + d.dx);
     const float dvdt = 1.0f/6.0f * (a.dv + 2.0f*(b.dv + c.dv) + d.dv)

     state.x = state.x + dxdt * dt;
     state.v = state.v + dvdt * dt;
}
以上就是一次完整的RK4积分算法的计算机实现.RK4积分算法对可以线性差值的积分都有效,所以说角速度的变化也可以应用RK4积分.在游戏中对于3D物体的旋转表示有三种方法,一种是欧拉角度,一种是矩阵,一种是四元数.欧拉角虽然形式简单但是会引起著名的Gimbal Lock[12]问题,也就是说在一些特定的场景下无法进行线性插值.而游戏中的飞船必须能够面对所有的角度,所以不可以使用欧拉角.矩阵表示是最强大而且最通用的一种旋转表达方式.但是矩阵数据过于复杂,运算量大,而且非常不直观,最重要的是无法进行简单的线性插值,那么就无法带入RK4积分算法.本课题最后使用四元数作为物件旋转的表示方案.使用四元数有很多优点.首先四元数不受Gimbal Lock问题的困扰,而且四元数接受线性插值,旋转的叠加也非常的直观,只需要将两个四元数相乘就可以了.


### 缓动和速度和旋转判定和碰撞检测.
首所有的操作对实际3D物件的影响都是直接改动的force属性,然后force属性根据物体的质量生成加速度,再跟据前述的RK4算法对离散的时间进行拟合.这样打来的速度总是缓慢的变化这的,并且在最终趋近于稳定.

碰撞检测并不是采用的最完美遍历所有object的方式.首先会针对每个可以参与碰撞检测的物件建立一个表单,当需要判定碰撞的时候针对这个表单里面的物件进行判断.传统的三维碰撞检测的判断需要对物体的每个面进行判断,但是为了能够让大量的飞船在三维空间中同时存在而不导致的效率急剧下降,我们参用了简化版本的三维碰撞检测,首先我们需要判断两个碰撞的物体是否远大于他们的最大三维尺寸加上他们的速度,如果确实是大于那么就不需要做更加复杂深入的判断.当他们确实在相应的距离里的时候,针对两个物体的运动速度取其合,并且在最后得到的速度方向上做射线,计算射线和目标点的距离,最后判断目标点的距离和射线其实点的距离到底有多大的差距,当差距在一个速度单位之内的情况下则认为他们家下来的一个单位时间里会相交,也就是说会碰撞,否则我们认为他们不会碰撞.

如果我们认定他们会发生碰撞那么碰撞点就取目标物体到射线上的垂直投影,认为这个投影点映射到真实的三维空间里去的点就是他们在真是三维空间里的相交点.然后针对所有需要做碰撞的物体如果是量两之间那么可以通便单次运算从而避免复杂的重复计算.通过采用这种大大优化过了的碰撞检测方式我们可以最大程度的将运算避免,从而总体上提高了碰撞检测的效果,并且依然保证了肉眼可以验证的运算效率.可以在20ms内对将近1000个物体进行碰撞检测而丝毫没有什么问题.

## 后台服务器的设计和实现
后台的服务其模块主要是和前台物理模拟部分的代码共享,通讯协议模块.

### 代码共享模块
由于后台的js模块之间使用的是commonjs模块2.0标准.这个标准是一个同步阻塞的标准,在模块引入之前会阻塞知道模块成功载入,变成非常方便.但是前端的模块载入是异步的,只能按照js引入的顺序加载才能同步.按需加载必须是异步的.这样就为前端和后台共享代码造成了一定的困扰.为了解决这个问题,我只做了一套兼容库,先按照前台的方式同步顺序同步载入,全部载入完成之后在伪造commonjs里的require方法同步返回全局对象,然后直接通过全局对象引用模块.这样只需要在浏览器端引入额外的兼容层就可以支持标准了.但是这样做也是有一个缺点的.缺点是会污染全局变量,模块与模块之间也并没有真正意义上的隔离.所以作为不到1w行的小项目,这个方案还是可行的,但是对于真正的大项目,则应该采用更加复杂的方案比如seajs[link to sea js] 这种AMD模式的异步加载库或者browserify[link to browserify]的预编译功能达到后台前台的代码共享.

### 通讯模块
与传统的实时web构架不同,多人游戏开使用HTTP Long Pull 长连接效率不够无法有效的翔服务器发送信息,开销也非常大.这里我们使用了基于HTML5标准的websocket接口构建客户端与服务器的通讯.
同样为了能够在服务器端和客户端之间有效合理的共享代码,这里写了一个中间层的基类叫做RPCtunnel,基于nodejs标准的eventEmitter事件发生器.然后基于RPCTunnel 通过不同的传输方式比如server端的websocket库ws,或者浏览器端的websocket构建统一的接口.抽象成对Remote Public Call的形式.那么远程的通讯就变成了直接函数调用编程非常方便.

另一方面,考虑到游戏对实时性的需求,除了部分信息同步的RPC,所有的RPC都是默认不等待返回值的.然后通过发送命令时的同步矫正来纠正传输过程中因为时间或者网络延迟所导致的问题.这样做的好处能大大的减少延时.但是也引入了新的问题.问题主要来自与这样的情况:当客户端擅自的对可能发生的状况做了不可挽回的模拟(比如舰船被集中了,并且消灭了),这样的话就到之了不可逆的状况,因此对于这种不可以相遇的模拟(prediction)必须禁止,避免玩家感受到过于大的跨度而产生不自然的印象.

而对于游戏之外的API比如用户登录,积分等同步则使用基于HTTP构建的RPC通过这种RPC虽然流量有所增加但由于不是流式的,采用这种高层协议实现RPC的优点在于不用保持活跃链接的,因此在通讯人数激增的情况小可以维持更小的持续性开销. 为了所小流量的开销,增加实时性能,对于玩家操纵的飞船采用了位封装,用单独的不重合的比特位来标志舰船的状态如下.
Ship.State = {
    left:              "1",
    right:            "10",
    up:              "100",
    down:           "1000",
    forward:       "10000",
    fire:         "100000",
    explosion:   "1000000",
}
do ()->
    for state of Ship.State
        Ship.State[state] = binaryToInt(Ship.State[state])

这样一来可以通过特定的比特的结合而合成一个非常小的数字,这个数字作为字符串在传输的过程中经过base64的压缩也会大大减小体积.
所有的动作都是可以重合的,至于重合后采用什么逻辑则是交给后台去判断了.这样用最小的位数传输了最大的信息.

在服务器收到新的指令之后会回传被修改的舰船的状态回传的包括:
{
            id:@id,
            constructor:"PhysicsObject",
            position:{x:@position.x,y:@position.y,z:@position.z},
            force:{x:@force.x,y:@force.y,z:@force.z},
            rotateAcceleration:{x:@rotateAcceleration.x,y:@rotateAcceleration.y,z:@rotateAcceleration.z},
            rotateVelocity:{x:@rotateVelocity.x,y:@rotateVelocity.y,z:@rotateVelocity.z},
            velocity:{x:@velocity.x,y:@velocity.y,z:@velocity.z},
            quaternion:{x:@quaternion.x,y:@quaternion.y,z:@quaternion.z,w:@quaternion.w},
	    state:@state
}
id 是舰船的全局唯一标志符号,从0开始递增.
constructor 是舰船的类型,可以是初始参数不同的舰船
position 是当前坐标
force 是推进力
rotateAcceleration 是旋转加速度
rotateVelocity 是旋转速度
velocity 是当前速度
quaternion 是表示舰船当前旋转量的四元数
state 之前描述的舰船的状态
通过描述这样一组舰船的元数据就能够达到更新和矫正客户端舰船数据的作用.

# 总结与展望
本课题主要完成了以下工作
  (1) 通过对Web前端和后台系统的构架,HTML5应用开发和HTTP服务器部署的学习,设计并实现了一种利用HTML5和WebGL技术构架的多人实时3D联机游戏。
  在系统的开发过程中,学习了HTML5的许多新型API,熟练掌握了图像渲染的相关方法和技术,并在服务器的设计中了解到了服务器的兵法和可靠性相关的知识,学习到了异步操作的一些技巧.
  通过在游戏开发的过程中使用WebSocket和自己定义的bit协议,大大减少了本应该有的延迟,提高了游戏体.
  (2) 算法上了解并探索了RK4算法在网络传输中物理模拟的使用,并且优化了,网络传输部分,从而证实了HTML5技术在网络游戏开发方面的可靠性.
  (3) 探索了后端和前端使用同样的代码来解决一致性问题.传统方式需要通过大量的测试和修改才能够达到不同语言间的一致性,而通过使用nodejs并且巧妙的构造前端的类Module2.0方式的模块导入,起到了模块共享的作用,也因此快速的开发完成了物理模拟的前端和后台模块,却不用做太多的体力劳动.从实践上为后面的开发者证明了共享一份代码是可行的. 
  如图所示[Image #9]通过实现上述的工作,本课题完整的实现了一套基于HTML5的3D多人联机游戏,结合了之前提到的业界前沿的联机和3D渲染技术.探索了web开发的新的可能性,尝试着吧Web开发领域又向前推了一步,希望能够给后面的开发人员和游戏参商一些参考和借鉴意义.

  本课题的眼界虽然取得了一定的收获,但是在很多方面还有待于进一步的改进和完善.比如,在3D渲染和物理引擎方面:
  a) 模型是有的是第三方的模型,并没有非常细致的刻画.另一方面由于缺乏对vbh动画的支持,因此游戏中的动画全部都只包涵刚体,所以只能移动和旋转,却不能变形.如果游戏中的物体可以变形那么将带来完全不同的体验.渲染方面高斯模糊的加入也有一些突兀,在战斗机受损的情况下与其加入高斯模糊不如加入背景变成灰色的效果,这样更能够体现游戏感,让玩家更有代入感.
  b) 物理引擎方面还有许多的缺陷比如不能炮火和目标的判定没有办法做到很好的判定.如果可以优化,后期的目标应该是判定的精确度.由于判定不够精确所以经常会出现应该击中但是没有击中的情况,给玩家带来了困扰.
  c) 画面动感设计不足,导致没有办法很好的给玩家游戏反馈,不如周围没有别的船只的时候无法看出自己的船只在动.如果加入一些小型的行星应该能够很好的改善这个效果.
  
  在游戏系统设计方面:
  1) 游戏没有一个很好的目标,只是不断的玩家之间的搏斗,所以很容易厌倦,应该加入中期的目标,比如组成团队然后参与团战,提高游戏的乐趣.
  2) 游戏没有设计奖励机制,玩家击落敌军不会有额外的反馈,因此玩的时候也不会有太多的代入感,这个需要花时间去设计.一款游戏如果无法让玩家产生代入感和成就感,那么往往就不会留住玩家,那么这就是一款失败的游戏.
  3) 没有玩家登陆和认证系统,每次玩家都需要重新登陆,这样会导致游戏体验不连贯。

  总体上来说,本课题成功的实现了最初的目标,设计并优化了一套给予HTML5的3D联机游戏的开发流程,并且指出了之后的研究方向,希望能确实的给其他的开发人员帮助与提示.

# 致谢
  经过大学四年的成长和自己不断的努力工作学习,终于在即将毕业之际完成了华中科技大学的本科生毕业论文和毕业设计.这次的毕业设计是对我大学思念的学习成果和学习方法的一次检验,也对我将来的发展,科学探索,和文档书写,踏实工作态度进行了考研.不知不觉的,这篇论文也接近了尾声,我的心中充满了自豪感,我明白了,我大学四年的努力学习没有白费,我即将成为一名合格的华中科技大学本科毕业生.
  作为一名专业只是还并不丰富的普通本科学生的毕业设计,有许多只是没有办法独立获取,经验积累的不足加上能力的锻炼不够,在毕业设计的过程中出现了多次碰到困难无法独立解决的情况.如果没有导师的细心帮助和督促指导,我很难想象我能够完成这次设计.
  这里首先要感谢我的指导老师胡卫军老师.大四的大部分时间我因为在外实习的原因,并没有百分之百的投入到毕业设计中去.胡老师为人随和,对我的情况非常理解,并且努力的帮我安排如何平和毕业设计和工作上的时间.在设计上出现问题的时候,老师也细心的提出了修改的条件.尤其是在最后的关头,论文撰写并不是我的特长,第一次审查的时候非常糟糕,但是胡老师并没有放弃我,而是给予了我很多有意义的意见,帮助我顺利的完成了这篇论文,也希望我这篇论文最后能够对的起胡老师的辛勤指导.所以我首先要感谢胡老师,谢谢您了!
  


感谢大学四年来对我不离不弃的同学们,帮助我度过了大学中的一个有一个难关,让我突破了一个又一个的技术难点,我从一个什么都不懂的学生成长为如今的优秀毕业生,并且能够完整的写出一片可以运行的游戏,这在我刚入大学的时候是不可以想象的.但如今我却确确实实的在这里,我不得不表示对那些给予我帮助的同学们以由衷的感谢.另外感谢大学四年来教我所有课程的所有老师,是你们给了我知识,是你们让我变得与众不同,如果没有你们想必我是不可能写出这篇论文的,没有你们我更时不可能座位一个优秀的学生而毕业的.然后我要感谢我的父母,是你们这么多年辛勤的把我养育大,在我论文书写不顺利的时候鼓励我,然我有了写下去的激情和动力,是你们为我做了一次又一次的饭,让我感受到了人生的美好.最后,我要感谢我这篇论文的指导老师胡卫军,是在您的指导下我才能够顺利的完成论文,实现重要的技术突破,从而作为一名学生毕业.如今,我要感谢你们,真的感谢你们,因为你们我才能够实现一个学生的目标.谢谢!


HTML5 是什么,从哪里来的.HTML5 有什么优点,HTML5 面临了哪些问题
HTML5 的普及率
HTML5 和游戏制作的关系
引入WebGL Threejs 和 Chrome Debugger.
课题的目的和意义和难点.
网络延迟,javascript的性能,GPU加速Shader.

国内外的研究现状

主要的研究工作
3D物理模拟,基于websocket的同网络延迟同步

人们用

表格 For Protocol
JSON数据解析
JSON协议数据的美剧表格

====================
WebGL
ThreeJs